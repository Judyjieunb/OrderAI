# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a fashion retail analytics project that analyzes 25S season sales data to optimize 26S season ordering. It combines Python data analysis with a React visualization dashboard and AI-powered budget control.

**GitHub**: https://github.com/Judyjieunb/OrderAI

**Key Business Logic:**
- Analyzes sell-through rates, inventory balance, and opportunity costs
- Uses BCG Matrix classification for item efficiency
- Implements AI-based demand forecasting with a goal-oriented decay model
- Detects both physical stockouts and "commercial stockouts" (broken assortment from size imbalance)
- AI budget control: Claude API suggests category-level budgets, which serve as ceilings for order recommendations

## Commands

### Frontend (React + Vite)
```bash
npm install          # Install dependencies
npm run dev          # Start dev server on port 3000
npm run build        # Production build
```

### Python Analysis Pipeline
```bash
# Install Python dependencies
pip install -r requirements.txt

# Run complete analysis pipeline (recommended)
cd scripts && python run_all.py

# Or run individual steps:
python scripts/main.py              # STEP 1: Season closing analysis + JSON export
python scripts/weekly_analysis.py   # STEP 2: Time series pattern analysis
python scripts/ai_sales_loss_v2.py  # STEP 3: AI demand forecasting & opportunity cost
python scripts/step4_integration.py # STEP 4: Similar style mapping → order recommendation
```

### FastAPI Backend (AI Budget Control)
```bash
# Requires ANTHROPIC_API_KEY env var for Claude API (falls back to rule-based without it)
uvicorn server.api:app --port 8000 --reload
```

## Architecture

### Analysis Pipeline (4-Step Process)

1. **main.py** - Season Closing Analysis (STEP 1)
   - Input: `data/sql_result_raw.xlsx`
   - Output: `output/25S_Analysis_Result.xlsx` (4 sheets with charts), `public/season_closing_data.json`
   - Performs 4-level analysis: Total Season → Category → Item (BCG Matrix) → Style
   - Generates grades (S/A/B/C/D) based on sell-through rate thresholds: ≥75%/65%/55%/40%

2. **weekly_analysis.py** - Time Series Pattern Analysis (STEP 2)
   - Input: `data/weekly_dx25s.xlsx`
   - Output: `output/25S_TimeSeries_Analysis_Result.xlsx`, `public/dashboard_data.json`
   - Detects reorder events, stockout timing (70% sell-through threshold)
   - AI diagnosis categories: Hit, Normal, Early Shortage, Shortage, Risk

3. **ai_sales_loss_v2.py** - AI Demand Forecasting (STEP 3)
   - Calculates opportunity cost using adaptive decay model
   - Formula: `r = (10 / P_avg)^(1/W)` where P_avg is 4-week average velocity, W is weeks remaining
   - Updates Excel with `AI계산 기회비용` and `AI제안 발주량` columns
   - Updates dashboard JSON with `potential_sale` and `loss` per data point

4. **step4_integration.py** - Similar Style Mapping → Order Recommendation (STEP 4)
   - Input: `data/similarity_mapping.csv` + STEP 2/3 results
   - Output: `output/26S_Order_Recommendation.xlsx` + `.json`
   - Applies budget ceiling from `output/budget_config.json` (if exists)
   - Proportionally scales recommendations when category totals exceed ceiling

### Backend (FastAPI)

- `server/api.py` - AI Budget Control proxy
  - `POST /api/budget-proposal` — Calls Claude API with season closing data, returns budget suggestion
  - `POST /api/budget-config` — Saves confirmed budget to `output/budget_config.json`
  - Falls back to rule-based proposal if `ANTHROPIC_API_KEY` not set

### Frontend Structure

- `src/main.jsx` - Entry point
- `src/App.jsx` - Main app with top tab navigation (Step 0~5)
- `src/components/SeasonClosing.jsx` - Season closing dashboard (KPI, balance grouped bar, BCG scatter, grade distribution)
- `src/components/BudgetControl.jsx` - AI budget control modal (Claude API proposal + manual adjustment + confirm)
- `src/components/Dashboard.jsx` - Time series analysis dashboard
- `src/components/SizeAssortment.jsx` - Size assortment optimization
- `public/season_closing_data.json` - Season closing data (generated by main.py)
- `public/dashboard_data.json` - Time series data (generated by weekly_analysis.py)

### Data Flow
```
STEP 1 (팀장급 의사결정)
sql_result_raw.xlsx ─→ main.py ─→ 25S_Analysis_Result.xlsx
                                 │
                                 └─→ season_closing_data.json ─→ SeasonClosing.jsx
                                                                      │
                                      [AI 예산 제안] ←─ server/api.py ←┘
                                            │
                                            ▼
                                      budget_config.json (카테고리별 천장)
                                            │
STEP 2~4 (담당자급)                          ▼
weekly_dx25s.xlsx ─→ weekly_analysis.py ─→ dashboard_data.json ─→ Dashboard.jsx
                            │
                            └─→ ai_sales_loss_v2.py ─→ Updates Excel & JSON
                                                            │
similarity_mapping.csv ─→ step4_integration.py ─→ 26S_Order_Recommendation.*
                          (예산 천장 자동 스케일링)
```

### Key Data Columns
- **Standard mappings** (auto-detected from various naming patterns):
  - `ORDER_QTY` / `IN_QTY` → Order/Inbound quantity (ORDER_QTY takes precedence)
  - `SALE_QTY` → Sales quantity
  - `STOCK_QTY` → Calculated as IN_QTY - SALE_QTY if missing
  - `CLASS2` → Category (복종), `ITEM_NM` → Item name, `STYLE_CD` / `PART_CD` → Style code

### Dashboard JSON Structure
```json
{
  "success": {
    "hit": [{ "total": {...}, "colors": {...} }],
    "normal": [...]
  },
  "failure": {
    "early_shortage": [...],
    "shortage": [...],
    "risk": [...]
  }
}
```

### Budget Config JSON Structure
```json
{
  "season": "26S",
  "confirmed_at": "2026-02-03T16:30:00Z",
  "total_budget": 1780000,
  "category_budgets": [
    { "class2": "Inner", "budget_qty": 980000 },
    { "class2": "Outer", "budget_qty": 430000 }
  ]
}
```

## Korean Font for Charts

Python matplotlib charts require Korean font configuration:
- macOS: `'AppleGothic'` or `'NanumGothic'`
- Windows: `'Malgun Gothic'`

Configured in `main.py` visualization functions via `plt.rcParams['font.family']`.


## Coding Guidelines (Karpathy-Inspired)
Behavioral guidelines to reduce common LLM coding mistakes. Merge with project-specific instructions as needed.

Tradeoff: These guidelines bias toward caution over speed. For trivial tasks, use judgment.

1. Think Before Coding
Don't assume. Don't hide confusion. Surface tradeoffs.

Before implementing:

State your assumptions explicitly. If uncertain, ask.
If multiple interpretations exist, present them - don't pick silently.
If a simpler approach exists, say so. Push back when warranted.
If something is unclear, stop. Name what's confusing. Ask.
2. Simplicity First
Minimum code that solves the problem. Nothing speculative.

No features beyond what was asked.
No abstractions for single-use code.
No "flexibility" or "configurability" that wasn't requested.
No error handling for impossible scenarios.
If you write 200 lines and it could be 50, rewrite it.
Ask yourself: "Would a senior engineer say this is overcomplicated?" If yes, simplify.

3. Surgical Changes
Touch only what you must. Clean up only your own mess.

When editing existing code:

Don't "improve" adjacent code, comments, or formatting.
Don't refactor things that aren't broken.
Match existing style, even if you'd do it differently.
If you notice unrelated dead code, mention it - don't delete it.
When your changes create orphans:

Remove imports/variables/functions that YOUR changes made unused.
Don't remove pre-existing dead code unless asked.
The test: Every changed line should trace directly to the user's request.

4. Goal-Driven Execution
Define success criteria. Loop until verified.

Transform tasks into verifiable goals:

"Add validation" → "Write tests for invalid inputs, then make them pass"
"Fix the bug" → "Write a test that reproduces it, then make it pass"
"Refactor X" → "Ensure tests pass before and after"
For multi-step tasks, state a brief plan:

1. [Step] → verify: [check]
2. [Step] → verify: [check]
3. [Step] → verify: [check]
Strong success criteria let you loop independently. Weak criteria ("make it work") require constant clarification.

These guidelines are working if: fewer unnecessary changes in diffs, fewer rewrites due to overcomplication, and clarifying questions come before implementation rather than after mistakes.